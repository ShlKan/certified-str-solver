\section{Introduction}
\label{sec:introduction}

Finite Automata (FA) and Finite Transducers (FT) are fundamental constructs in the theory of formal languages, with extensive applications in programming 
languages and software engineering. Despite this, many practical applications
that employ FAs and FTs --- for example, string analysis for web applications
%character sanitization in web
%applications 
(which easily prone to XSS vulnerabilities) and string constraint solving
--- require extremely large alphabets (e.g. UTF-16), which are beyond the
capabilities of classical automata algorithms
\cite{DV21,cav/DAntoniV17,uss/HooimeijerLMSV11,Berkeley-JavaScript}.
More precisely, explicit automata/transducer representations would yield 
an extremely large number of transitions (potentially, one for 
each letter).
%For example, recent advancements in string solvers, as demonstrated by \cite{pacmpl/ChenFHHHKLRW22}, have illustrated the relationship between regular expressions in modern programming languages and various forms of FAs and FTs. Additionally, FAs and FTs find significant industrial applications, such as in the verification of AWS access control policies \cite{DBLP:conf/fmcad/BackesBCDGLRTV18}.



%One significant drawback from classical automata approach is that transition 
%labels are typically non-symbolic and finite. A conventional transition is represented as $q\xrightarrow{a}q'$, where $a$ is a character from a finite alphabet. This simplistic representation can lead to a phenomenon known as transition explosion. 
%For example, if the alphabet $\Sigma$ encompasses the entire Unicode range, which is common in modern programming languages, it consists of $\texttt{0x110000}$ distinct characters. Defining a transition from state $q$ to $q'$ that accepts any character in $\Sigma$ would require splitting into $\texttt{0x110000}$ individual transitions, rendering the FA and FT operations highly inefficient. Furthermore, in practical applications, it is often necessary to consider infinite alphabets, such as the set of all integers.

%Even though there are various formalizations of FAs and FTs in interactive proof assistants such as Isabelle \cite{isabelle-homepage} and Coq \cite{coq-homepage}, these are predominantly based on classical definitions. However, these traditional approaches present certain limitations when applied to practical scenarios. 



Symbolic Finite Automata (SFA) and Symbolic Finite Transducers (SFT)
\cite{cav/DAntoniV17, VeanesHLMB12Transducer,DV21} were proposed around 15 years ago
to deal with the alphabet-explosion problem that often arises in practical
applications. 
%represent advanced extensions of classic FAs and  FTs, enhancing their applicability in practical scenarios.
%
These symbolic extensions permit transition labels defined by an effective 
boolean algebra, allowing for a succinct representation of a set of transitions
that can be conveniently manipulated. 
%more expressive representations. 
For example, in the interval algebra, a transition label might be specified as 
an interval [$\texttt{a}-\texttt{z}$], encompassing all characters from
$\texttt{a}$ to $\texttt{z}$. As another example, in the SMT-Algebra
(particularly, of the theory of Linear Integer Arithmetic), %or 
one could associate an arithmetic condition ($x \mod 2 = 0$) to a transition, 
denoting all even numbers. Efficient algorithms for manipulating (e.g. computing
closures) and analyzing (e.g. checking emptiness) SFA and SFT are by now
rather mature (e.g see the CACM article \cite{DV21}).
SFA and SFT have been applied in numerous domains including analysis of web
applications against XSS vulnerabilities \cite{VeanesHLMB12Transducer,uss/HooimeijerLMSV11},
runtime behavior monitoring \cite{osdi/YaseenABCL20}, automated program
transformation \cite{pldi/HuD17}, and finally SMT solving for the unicode theory
of strings (e.g. see \cite{pacmpl/ChenFHHHKLRW22,CHL+19}).
%Furthermore, numerous studies have demonstrated the broad applicability of SFTs across diverse domains. The work of \cite{VeanesHLMB12Transducer} showcases SFTs in security-critical applications, particularly for cross-site scripting (XSS) prevention. \cite{uss/HooimeijerLMSV11} extends this security focus by applying SFTs to web application sanitizer analysis. In system verification, \cite{osdi/YaseenABCL20} employs SFTs for runtime behavior monitoring, while \cite{pldi/HuD17} demonstrates their utility in automated program transformation through systematic inversion techniques.
%This symbolic approach not only provides a more succinct representation but also supports infinite alphabets, thereby extending the expressive capabilities of FAs and FTs.

Owing to the security-critical nature of many applications of string analysis
(e.g. analysis of web applications against XSS vulnerabilities
\cite{Berkeley-JavaScript} and
at AWS for analyzing Role-Based 
Access Control (RBAC) policies \cite{neha,DBLP:conf/fmcad/BackesBCDGLRTV18}), 
there is an 
increasing need of trustworthy implementations in such application domains. 
Unfortunately, string analysis implementations are often quite buggy. For
example, even state-of-the-art SMT solvers over the theory of strings 
were found to be buggy through such techniques as fuzzing
\cite{DBLP:conf/cav/BlotskyMBZKG18,BM20,Mansur20}. 
%Recent applications of string solvers in security critical applications
%(e.g. at AWS for analyzing Role-Based 
%Access Control (RBAC) policies \cite{neha,DBLP:conf/fmcad/BackesBCDGLRTV18})
This
has motivated initial formalization efforts for the theory of strings in 
Isabelle/HOL, e.g., a verified solver \cite{cpp/KanLRS22}
for handling a small fragment of SMT-LIB 2.6 unicode theory of strings
consisting only of equality, concatenation and regular constraints, and a
formalization of the semantics of this theory \cite{verified-verifying}.

Despite these, existing verified implementations for string analysis do not
handle the following indispensable string operations for analysis of web
applications (e.g. see
\cite{DBLP:conf/popl/LinB16,Kern,Berkeley-JavaScript,systematic-transduction,uss/HooimeijerLMSV11}):
\emph{string transductions} and \emph{replaceall} operators. In particular, 
string transductions are used frequently in web applications (e.g. for
sanitization, as well as implicitly applied transductions, for instance
through \texttt{innerHTML}) and are well-known to be critical for analyzing XSS
vulnerabilities for web applications
\cite{Berkeley-JavaScript,systematic-transduction,Kern,uss/HooimeijerLMSV11,DBLP:conf/popl/LinB16}. In particular, SMT-LIB string constraints that 
arise from such applications require the \emph{replaceall} operator, which is currently not handled by any existing verified
implementation. This paper tackles the formalization of SFA/SFT and
their associated algorithms, as well as applications to analysis of sanitizers
and verified solver for string constraints. 
%\textcolor{red}{Updated up to here
%so far}

\OMIT{
SFA and SFT (e.g. 
analysis of web applications, e.g., against XSS vulnerabilities), 

However, the formalization of transition labels in SFAs and SFTs presents significant challenges within interactive proof assistants. Two fundamental considerations arise: first, the representation of transition labels must be sufficiently expressive to accommodate diverse predicate representations of boolean algebras; second, the formalization framework must be designed with extensibility in mind to facilitate the incorporation of new boolean algebras while minimizing redundant proof efforts.

}


\OMIT{
Prior work of CertiStr \cite{cpp/KanLRS22} has successfully formalized SFAs within Isabelle/HOL, demonstrating both the efficiency and effectiveness of SFAs in practice. However, the formalization of SFTs remains an open challenge, primarily due to their inherent complexity in two aspects: the formalization of transition labels and the specification of transition output functions. SFTs constitute a significantly more expressive and powerful theoretical framework compared to  SFAs, as evidenced by their capability to model complex string transformations such as replacement operations.
%
Furthermore, numerous studies have demonstrated the broad applicability of SFTs across diverse domains. The work of \cite{VeanesHLMB12Transducer} showcases SFTs in security-critical applications, particularly for cross-site scripting (XSS) prevention. \cite{uss/HooimeijerLMSV11} extends this security focus by applying SFTs to web application sanitizer analysis. In system verification, \cite{osdi/YaseenABCL20} employs SFTs for runtime behavior monitoring, while \cite{pldi/HuD17} demonstrates their utility in automated program transformation through systematic inversion techniques.
}


\paragraph{Contributions.} 
In this work, we present a comprehensive formalization of SFTs. 
%However, the formalization of transition labels in SFAs and SFTs presents significant challenges within interactive proof assistants. 
Two fundamental considerations arise in such a formalization: first, the 
representation of transition labels must be sufficiently expressive to accommodate diverse predicate representations of boolean algebras; second, the formalization framework must be designed with extensibility in mind to facilitate the incorporation of new boolean algebras while minimizing redundant proof efforts.

To address these challenges, %in supporting diverse transition label theories, 
we adopt a refinement-based approach. At the abstraction level, transition labels are formalized through the fundamental mathematical concept of \emph{sets}. This abstraction facilitates subsequent refinement to various representations of Boolean algebras, such as intervals and arithmetic predicates, while maintaining theoretical consistency.

The key operation of our formalization is the product operation between an SFT and an input regular language. Specifically, given an SFA $\mathcal{A}$ representing a regular language and an SFT $\mathcal{T}$, we define the product operation $\mathcal{T} \times\mathcal{A}$ that characterizes the output language generated by $\mathcal{T}$ when processing inputs from the language recognized by $\mathcal{A}$.


In the refinement level, we implemented transition labels using an interval-based representation to examplify the refinement process. The formalization of interval algebra provides efficient set-theoretic operations—including membership checking, intersection, and difference computations—facilitating the refinement of transition labels from abstract sets to concrete intervals. Furthermore, leveraging the data refinement framework \cite{DBLP:conf/itp/Lammich13} in Isabelle/HOL, we store states and transitions using sophisticated data structures such as hashmaps and red-black trees, ensuring efficient automata manipulation.

To evaluate the effectiveness and efficiency of our formalization, we 
provide two applications: (1) analysis of the web application sanitizers for html, css, json, and javascript
which are used for preventing XSS attacks, and (2) string solving handling equality, concatenation, regular
constraints, and more importantly the string replaceall operator, which has been
argued to be indispensable for analysis of XSS
\cite{DBLP:conf/popl/LinB16,Kern,Berkeley-JavaScript,systematic-transduction,uss/HooimeijerLMSV11}.
The experimental results demonstrate that our formalization achieves computational efficiency in constraint-solving scenarios.

\OMIT{
which increasingly
extended

the SMT-LIB \cite{smtlib} compliant certified string solver \cite{cpp/KanLRS22}
with replacement operations. We evaluated our implementation using a set of benchmarks from the SMT-LIB repository \cite{smtlib_benchmarks}.
}



In summary, our formalization makes the following contributions:
\begin{enumerate}
\item We present the first formalization of symbolic finite transducers  in Isabelle/HOL.
We prove the correctness of key operations of SFTs and symbolic SFAs, such as the product operation between SFTs and SFAs.
\item We leverage the refinement framework to develop an extensible and efficient SFT implementation capable of supporting diverse Boolean algebras, ensuring adaptability to future transition label representations. The correctness of the refined, efficient implementation is proved via structural isomorphism between refinement layers.
\item We develop a certified interval algebra with verified set-theoretic operations, enabling refinement of transition labels from abstract sets to concrete intervals.
\item We demonstrate the practical utility of our formalization by applying it to sanitizer analysis and integrating our formalized SFT into the verified forward-propagation string solver CertiStr \cite{cpp/KanLRS22}. This integration extends CertiStr from supporting only simple concatenation and regular constraints to handling more sophisticated string replacement operations.
\end{enumerate}

\paragraph{Organization.}
The remainder of this paper is organized as follows:
Section \ref{sec:motivation} provides concrete motivating examples.
Section \ref{sec:sft} introduces the definition of symbolic finite transducers and their product operations.
Section \ref{sec:formalization} presents our formalization of SFTs in Isabelle/HOL.
Section \ref{sec:application} demonstrates applications to sanitizer analysis and string constraint solving.
Section \ref{sec:related-work} discusses related work.
Section \ref{sec:conclusion} concludes and outlines future directions.
