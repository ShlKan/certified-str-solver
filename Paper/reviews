CPP 2026 Paper #58 Reviews and Comments
===========================================================================
Paper #58 Certified Symbolic Finite Transducers: Formalization and
Applications to String Analysis


Review #58A
===========================================================================

Overall merit
-------------
4. Accept

Reviewer expertise
------------------
3. Knowledgeable

Paper summary
-------------
The paper presents an Isabelle/HOL formalization of symbolic finite transducers, finite transducers where input/output symbols are representation of sets of characters, rather than single characters.
They instantiate to interval representations (modeling [A-Za-z] etc.). They derive implementation CertiStrR, and experimentally evaluate on:

A. models of existing string sanitizers over attack models. They found HtmlEscape of Google Analytics and escapeString (where is this from?) are unsafe on the HTML attack model.

B. SMT-LIB benchmarks. CertiStrR performs order-of-magnitude faster than existing state-of-the-art solvers, which is a big surprise to me. I would like an explanation what makes CertiStrR that better than the state-of-the-art solvers.

From what I can tell, these results look quite significant and the paper should be accepted. I'm not confident enough to say strongly so, because of some missing informations:
1. Formal definitions of LTTS_reachable and L_e are not presented, which can (in principle) void the final correctness statement.
2. Is CertiStrR obtained via code export (at least partly)?
3. Is models in above A correct? If so, the authors found vulnerabilities and I suppose they make responsible action. Otherwise, more analyses would be appreciated.

Comments for authors
--------------------
65 "15 years ago": "2010" will remain true.

223 "any existing...": Please add "we know" etc.

280: several "." should be ","

395 "set option": "option set"? Otherwise I request explanation.

406 "The value None...": already said around 380.

408 "This design choice...": I cannot think of other (natural) choices which would not facilitate. I'd drop.

417 "rather than ... criteria.": Please simply say "to model nondeterminism." etc.

454: "(...) set" is missing. It should have been "('q × 'a × 'q) set" to be theoretically clearer.

459: I'd drop the technical definition.
  Readers are interested in it's correctness (productT_correct), for which L_e and LTTS_reachable are more important in order to trust. In any case, please make better use of Isabelle notation:
  "{((p,p'),S,(q,p')) | p p' S q f. p' ∈ Q A ∧ (p,(None,f),q) ∈ Δ_t T ∧ M_t T f None = Some S}"
  The same applies to 468.

498: This equation is wrong, according to the correctness statement (Fig.6).
Instead of parameterizing F, one should define it (with better name) via:
definition F f A = (if ∀a∈A. f a = None then None else...)
With such, you should discharge F_ok1 and F_ok2 from Fig.6.

512: Why do you put parentheses?

535: I would like to see the definition of LTTS_reachable.

542: Is L_e from existing work? Then please cite, otherwise please present the definition.

1008: Is this vulnerability known?



Review #58B
===========================================================================

Overall merit
-------------
3. Weak accept

Reviewer expertise
------------------
2. Some familiarity

Paper summary
-------------
String constraint solving is used in many software application,
including some critical security procedures. Many of the string
solving problems can be expressed in the formalism of Finite Automata
(FA) and/or Finite Transducers (FT). This paper formalizes Symbolic FA
and Symbolic FT (which were introduced to deal with big alphabets like
Unicode) in Isabelle/HOL. This formalization is then used in two
application - sanitizers for WEB applications and string replacement
operations. Implementation of these case studies are compared to other
two string solvers with favorable results.

SFAs and SFTs were first formalized on abstract level. Subsequently,
the abstract model was refined to various representations of Boolean
algebras such as intervals and arithmetic predicates.  The authors
mostly focused on the operation of product of SFA and SFT, since it
serves as a base for web sanitizing software. First they prove
correctness of such operation. Then they leverage the refinement
framework within Isabelle/HOL to develop an extensible and efficient
implementation that can support diverse Boolean Algebras. An example
is a certified interval algebra with verified set-theoretic
operations. The developed implementation is applied to a web sanitizer
and also incorporated into a string solver CertiStr as a certified
pattern replacement algorithm. Both implementations were
evaluated on some benchmarks. The former seems to be scalable to practical
applications. The latter was compared to Ostrich and CVC5 and the
CertiStr was a winner.

The formalization seems pretty straightforward and is well explained.
I haven't spotted any novel technique or unexpected result.

Comments for authors
--------------------
How does your string replacement algorithm deal with the overlapping
occurrences of the string?  Say if we are replacing "baab" in a string
"xbaabaaby"?

It looks to me that the SFT on Fig. 15 will replace any substring of
[0-9]+ with NUM. For instance input a123b, can be modified to aNUM23b,
or aNUM3b or aNUMb. Was that what you wanted?

In reporting test results in Section 5.2 for string replacement, you
do not explain what SAT/UNSAT means for the tests. Did I misunderstand
that you are performing string replacements? What are you checking?

Can you elaborate on this: "While classical automata theories have
been extensively formalized...the symbolic variants of automata and
transducers remain largrly unexplored in formal verification" . What
is the complication in formalization of FA/FT comparing to SFA?SFT?



Review #58C
===========================================================================

Overall merit
-------------
4. Accept

Reviewer expertise
------------------
3. Knowledgeable

Paper summary
-------------
This paper presents an Isabelle/HOL formalisation of symbolic finite transducers
(SFTs) and symbolic finite automata (SFAs), together with proving the
correctness of some core operations on them, such as the product of an SFT with
an SFA so as to compute the words/language resulting from applying the SFT to
the words/language accepted by the SFA. The authors develop their formalisation
at three levels of abstraction, with the most abstract layer specifying
transition labels etc only as sets, with set unions and other set operations on
them. The less abstract layers then allow one to implement these operations
using more concrete and fit-for-purpose Boolean algebras. The authors also
develop a certified interval algebra, and benchmark the formalisation by
applying it to sanitizer analysis and by integrating it into the verified
forward-propagation string solver CertiStr.

Generally speaking, the Isabelle/HOL formalisation of SFTs and SFAs looks
natural and mostly follows the corresponding pen-and-paper mathematical
definitions and proofs, which in my opinion is very positive. I also found it
pleasantly suprising that in addition to just formalising a library of SFTs and
SFAs, this work has also been applied in practice and quite successfully, as the
reported benchmarking shows. Therefore I recommend this paper to be accepted
because it provides a mechanised formalisation to an important area.

Comments for authors
--------------------
Regarding related work, you mention that not much has been done on the
formalisation of symbolic automata and transducers. While that is true in my
knowledge as well, then more recently there have been formalisation efforts
concerning e.g. symbolic derivatives and the accompanying mathematics by Zhuchko
and others (e.g., see Finiteness of Symbolic Derivatives in Lean by Zhuchko,
Maarand, Veanes, and Ebner). I think such related efforts deserve a remark.

In Figure 5, many primes have odd and wrong spacing. Please fix those.