
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository
\usepackage{stmaryrd}
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Certified Symbolic Transducer with the Application of String Solver} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Shuanglong Kan}{Barkhausen Institut, Germany \and \url{https://github.com/ShlKan} }{shuanglongkan@gmail.com}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.



\authorrunning{S. Kan} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Jane Open Access and Joan R. Public} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Dummy keyword} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{15th Conference on
Interactive Theorem Proving (ITP 2025)}
\EventShortTitle{ITP 2025}
\EventAcronym{ITP}
\EventYear{2025}
\EventDate{July 24--27, 2025}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstset{
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\bfseries,
	keywords={definition,if,then,else, where, record, fun, lemma, type_synonym, fixes, assumes, shows},
	escapeinside={|}{|}
}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Finite-State Automata (FA) and Finite-State Transducers (FT) are extensively utilized in programming languages and software engineering applications. For instance, regular expressions and their variations play a pivotal role in programming languages like JavaScript, Python, and others. Formalizing FAs and FTs in Coq, Isabelle/HOL, and other proof assistants are a popular topics. However, all these formalization are not practical in real-world applications. 
One of the reasons the transition labels are only single characters in the alphabet, for instance $q\xrightarrow{a} q'$ is a transition and $a$ is a single character. For real-world applications, the alphabet an FA or FT may be enormous or even \emph{infinite}. This classic way of transition definition can yield transitions explosion. 

A more practical way is to formalize symoblic FAs [1] and FTs [2], in which transition labels are symbolic and can be infinite. The work of [3] has done the work for FAs, but FTs 
have not yet been formalized, which pose more challenges on proving the correctness of the formalization.

In this paper, we aim to filling this gap. We gave a symbolic transducer formalization in Isabelle/HOL. The formalization is refinement-based and extensible with different symbolic representations of transition labels. In order to evaluate its effect and efficiency, we applied it to a  SMT string solver for modeling replacement operations in modern programming languages. The experimental results show the formalized symbolic transducer can efficient solver string constraints.


\end{abstract}

\section{Introduction}
\label{sec:introduction}

Automata and Transducers are crucial concepts in formal languages and have widely applications in programming languages and software engineering. For instance, [1] has shown the correspondence between  regular expressions in modern regular expressions and variants of FAs and FTs. Other industrial usage of FAs and FTs is AWS access control polices checking.


Even though there various  formalization of FAs and FTs in Coq, Isabelle, and other proof assistants. They are mainly based on classic definitions of FAs and FTs.  There some drawbacks when come to practical applications. (1) transition labels are 
non-symbolic and usually finite.
A classic and normal definition of a transition is $q\xrightarrow{a}q'$, where $a$ is a character in an finite alphabet.  This simple way will yield transition explosions. 
For instance, if the alphabet $\Sigma$ is of the size $10,000$, then a transition from $q$ to $q'$ that accept any characters in $\Sigma$ need to split into $10,000$ transitions. Automata product in this way will be very inefficient. Moreover, 
The alphabet are usually finite. For practical applications, infinite alphabet are often necessary. For instance, if the alphabet is all integers. 


Symbolic FAs and FTs [2,3,4] are extensions of classic FAs and FTs that make their application more practical. The transition labels are represented by algebra. For instances, intervals ($'a'-'z'$), boolean algebras ($x \% 2 == 0$), or others. This symbolic way is more succinct and its support for infinite alphabet extend the expressive power of FAs and FTs.

Formalizing FAs and FTs in Isabelle/HOL, Coq, and other proof assists are more challenging compare with formalizing classic ones. Moreover, how to make the formalization extensible is also an important point to think, because, symbolic FAs and FTs support different algebras symbolic representations. For new algebra representations, we do not want repeat some proof works.


Fortunately, symbolic FAs has been formalized in Isabelle/HOL [certistr] and experiments in [certistr] illustrates the efficiency and effective of symbolic FAs. Unfortunately FTs are not formalized yet.  FTs are more powerful and expressive than symbolic FAs. For instance, when FTs are support, replacement operation in modern programming languages, such as Javascript, python and others can be modelled as FTs. And CertiStr can be extended to support replacement operations.

In this paper, we formalize symbolic FTs based on symbolic FAs. In order to solve the potential extension problem of FTs to support additional transition label theories, the formalization is refinement-based, in which at the abstraction level, transition labels are modeled as a general concept: sets. We can project any theory to sets. \emph{extend this}.
The most important operation that we formalized and proved is the application operation on an input language.  More precisely, given an FA $\mathcal{A}$ (to represent a regular language) as the input language and a FT $\mathcal{T}$, the application operation $\mathcal{F}~\mathcal{A}$ is the  of output languages of FT after receiving the input language 

In the next refinement level, the states and transitions are stored in efficient data structure based on Isabelle/HOL refinement framework [2].
For transition labels, we implemented an interval algebra, which are efficient for creating, checking, interaction.
%
In the future the refinement of transition label from sets to other algebras instead of intervals can be done easily by implementing the common interfaces with interval algebras.

We highlight our formulization with the following points.
(1) Efficiency, the algebraic representation
support compressed storage of transition labels and efficiency checking
of membership.
(2) Extensible, the refinement based formulization allows the extension
of the SNFA to support different theories of transition labels.

The paper is organized as follows.
Section 2 presents the formalization of symbolic FTs.
Section 3 presents the Core operations of symbolic FTs.





\section{Formalization of Symbolic FTs}

We first present a mathematical form of FTs, which is independent of Isabelle's formalization. 
The key is the label theory, which defines how do output labels generated from input labels.

Let $\mathcal{U}$ be a multi-sorted carrier set or background universe, which is equipped with functions and relations over the elements. We use $\tau$ as a sort and $\mathcal{U}^\tau$ denotes the sub-universe of elements of type $\tau$. 
We have a special type $\mathbb{B}$ with $\mathcal{U}^\mathbb{B} = \{ \top, \bot\}$, which corresponds to the boolean type. Assume $\mathbb{N}$ is the set of elements of the sort natural numbers.

A lambda term is defined as $\lambda x. t$ of the type $\tau_1 \rightarrow \tau_2$.
When $\tau_2$ is $\mathbb{B}$, this lambda term is a predicate. Assume $\psi$ is a predicate. We write $a\in \llbracket\psi \rrbracket$ if $\psi~a=\top$. For the non-predicate lambda term, we view it as a function, which generates an output element of type $\tau_2$ with the input term of type $\tau_1$. 

\begin{definition}[Symbolic Finite Transducer]
\label{def-sft}
   A Symbolic Transducer over $\tau_1\rightarrow \tau_2$ is a quadruple $(\mathcal{Q}, \Delta, \mathcal{I}, \mathcal{F})$, where 
   \begin{itemize}
   \item $\mathcal{Q}$ is a finite set of states,
   \item $\mathcal{I}\subseteq \mathcal{Q}$ is the set of initial states,
   \item $\mathcal{F} \subseteq\mathcal{Q}$ is the set of accepting states,
   \item $\Delta$ is the set of transition relations. Each element in $\Delta$ is of the form $(q, \phi, f, q') (\text{or written in } q\xrightarrow{\phi, f} q')$, where $q$ and $q'$ are the states in $\mathcal{Q}$.
   $\phi$ is a predicate of type $\tau_1\rightarrow \mathbb{B}$.
   $f$ is a lambda term of the type $\tau_1\rightarrow \tau_2$. We call it output function in the following.
   \end{itemize}

For each transition $q\xrightarrow{\phi, f} q'$, if there exists an element $a\in \llbracket \phi \rrbracket$, where $a$ is called input,  then the application $f~a$ is the output.
   
\end{definition}

SFTs accept an input word and generate an output. This can be defined by runs of SFTs.
An SFT run $\sigma$ is a sequence of $(q_0, \psi_0, f_0, q_1),(q_1, \psi_1, f_1, q_2),\ldots, (q_{n-1}, \psi_{n-1}, q_n)$ such that $q_0\in \mathcal{I}_T$ and $(q_i, 
\psi_i, f_i, q_{i+1}), 0 \leq i \leq n-1$ is a transition in $\Delta_T$.
$\sigma$ is an accepting run when $q_n$ is an accepting state.
For a word $w = a_0,\ldots, a_{n-1}$, it is accepted by $\sigma$ iff $a_i \in \llbracket\psi_i \rrbracket$ for $0 \leq i \leq n - 1$. Run $\sigma$ will generate an output sequence if $w$ is accepted by it, which is $w'= (f_0~a_0), \ldots (f_{n_1}~a_{n_1})$. We denote this operation as $\mathcal{N}~w = w'$.


\subsection{The Isabelle/HOL Formalization of SFT}

\begin{figure}[t]
	\begin{lstlisting}
record (|$'q,$||$~'a,$| |$'b$|) |$\mathbf{NFT}$| =
	|$\mathcal{Q}_T$| :: "|$'q$| set"
	|$\Delta_T$| :: "(|$'q,$||$~'a,$| |$'b$|) LTTS"
	|$\mathcal{I}_T$| :: "|$'q$| set"
	|$\mathcal{F}_T$| :: "|$'q$| set"
        |$\mathcal{M}$| :: "|$'b\Rightarrow 'a$| Tlabel"
        
type_synonym |$('q, 'a, 'b)$| LTTS = "|$('q \times ('a \text{ set option }\times b) \times 'q)$| set"

type_synonym |$'a$| Tlabel = "|$'a \text{ option} \Rightarrow 'a$ set"
	\end{lstlisting}
\caption{The formalization of $FTs$ in Isabelle/HOL}
\label{fig-def-FT}
\end{figure}

Figure \ref{fig-def-FT} shows our formalization of SFTs in Isabelle / HOL. The elements $\mathcal{Q}$, $\mathcal{I}$, and $\mathcal{F}$ are intuitive when referring to Definition \ref{def-sft}. However, the transitions are not exactly the same. 
%
The set of transitions is defined by \texttt{LTTS} ( which is short for Labeled Transducer Transition System). Each transition is defined as $'q \times ('a \text{ set option }\times b) \times 'q$. There are some design decisions, which are made to make the FT formalization more flexible.

Firstly, $'a \text{ set option }$ is the type input of the transition, it accepts a set of elements of type $'a$ or \texttt{None} regarding the semantics of the type \texttt{option}. 
Accepting a set of $'a$ elements aims to express the same but more abstract semantics of the input labels in Definition \ref{def-sft}, in which an input label is a predicate. A predicate's semantics as introduced before represents a set of elements that make the predicate true. But predicates have various different forms. For instance, the interval $[1, 9]$ is a predicate that contains all elements $e$ between $1$ and $9$, i.e., $1 \leq e \leq 9$. The predicate $\lambda x : \mathbb{N}.~ x \text{ mod } 2 = 0$ denotes the set of even natural numbers. All these different forms of labels are abstracted as sets.

%
The value $\texttt{None}$ is used to denote $\varepsilon$-move, that is, it accepts nothing but may still output some elements. This design makes it easier model real world applications in FTs. We will show an example after introducing the output functions. 

The second element of type $'b$ is the \emph{indexes} of the output functions.  $\mathcal{M}$ maps each of these indexes to an output function. The output function, defined by \texttt{Tlabel} maps a single input element to a set of output elements instead of single one. The reason is to allow FTs output non-deterministically, which means that the output may randomly or according to some criteria select one of the element in the set to output.

Now let us look at an example. In some modern programming languages, there are support for replacement operations : $\texttt{replace}(\texttt{str}, \texttt{pattern}, \texttt{replacement})$. This operation replaces the first occurrence of the substring  in \texttt{str} that matches \texttt{pattern} (which usually a regular expression) with the string \texttt{replacement}). 
We can easily model this operation using our formalization of NFTs with the following steps:
\begin{itemize}
\item Step 1, construct a corresponding NFA from \texttt{pattern}).
\item Step 2, convert each transition label for transducers by adding a function that maps each input character to empty, that is, generate nothing.
\item Step 3, Add a new accepting state, and redirect existing accepting states to the new accepting state and transition label as $(\texttt{None}, \lambda x. \texttt{replacement})$.
\item Step 4, unlabel previous accepting states as non-accepting states. 
\end{itemize}

We can see that the definition of transition labels in NFTs makes it is very easy to model the replacement operation.

\section{The Key Operation of NFTs}

Given an NFT $\mathcal{N}$ and a word $w$, it is crucial and interesting that the possible output words can be calculated. This is the operation, we want to formalize, but we will generalize this operation.

Instead of calculating the outputs for a single word, the operation calculates the outputs for a set of input words. Single word input is a special case with the set contains exactly only one element.

The set of input words is modeled as a regular language. To be more precise, let $\mathcal{N}$ be an NFT, and $\mathcal{A}$ be an NFA. We define the operation $\texttt{PRODUCT} ~\mathcal{N}~\mathcal{A} = \{w'\mid w\in \mathcal{L}(\mathcal{A})\text{ and } w' = \mathcal{N}~\mathcal{A}\}$, where $\mathcal{L}(\mathcal{A})$ denotes the language of NFA $\mathcal{A}$.


But there is one thing we need to consider, as our NFT formalization accepts $\varepsilon$-transitions, the output NFAs may contain $\varepsilon$-transitions as well. Unfortunately, [CertiStr] does not formalize $\varepsilon-$NFA. We formalize symbolic $\varepsilon-$NFA and the conversion from $\varepsilon-$NFA to NFA. We only present the definitions of $\varepsilon-$NFA and NFA in this paper. The more details including correctness proofs can be found in the Isabelle code. 

\begin{figure}[t]
	\begin{lstlisting}
record (|$'q,$||$~'a$|) |$\mathbf{NFA}$| =
	|$\mathcal{Q}$| :: "|$'q$| set"
	|$\Delta$| :: "(|$'q,$||$~'a$|) LTS"
	|$\mathcal{I}$| :: "|$'q$| set"
	|$\mathcal{F}$| :: "|$'q$| set"

record (|$'q,$||$~'a$|) |$\mathbf{eNFA}$| =
	|$\mathcal{Q}_e$| :: "|$'q$| set"
	|$\Delta_e$| :: "(|$'q,$||$~'a$|) LTS"
        |$\Delta_e'$| :: "|$('q * 'q)$| set"
	|$\mathcal{I}_e$| :: "|$'q$| set"
	|$\mathcal{F}_e$| :: "|$'q$| set"

type_synonym |$('q, 'a)$| LTS = "|$'q \times 'a \text{ set }\times 'q$|"    
	\end{lstlisting}
\caption{The formalization of $\varepsilon-$NFA and NFA in Isabelle/HOL}
\label{fig-def-FAs}
\end{figure}

Figure \ref{fig-def-FAs} shows the definitions of NFA and $\varepsilon-$NFA.
The record type \texttt{eNFA} corresponds to $\varepsilon-$NFA. $\Delta_e$ is same as $\Delta$ in \texttt{NFA}. $\varepsilon$-transitions are defined by $\Delta_e'$.  Now we are ready to present the operation \emph{APPLICATION}. Let $\mathcal{T}$ be an SFT and  $\mathcal{A}$ be an NFA. The output language generated by $\mathcal{T}$ with the input language $\mathcal{A}$ is an an \texttt{eNFA} $\mathcal{A}'$. 

\begin{figure}[ht]
	\begin{lstlisting}
definition productT :: |$"('q,'a,'b,'c)"$| NFT |$\Rightarrow$| ('q,'a) NFA |$\Rightarrow$| 
           |$(('a,'b)$| Tlabel |$\Rightarrow 'a \text{ set}\Rightarrow 'b\text{ set option})\Rightarrow$|
           |$('q\times 'q, ~'b)$| eNFA where
  "productT |$\mathcal{T}$| |$\mathcal{A}$| F = |$\llparenthesis$|
    |$\mathcal{Q}e = \mathcal{Q}_t~\mathcal{T} \times \mathcal{Q} ~\mathcal{A}$|,
    |$\Delta_e = \{((p,p'),~\texttt{the }(((\mathcal{M}~\mathcal{T})~f)\texttt{ None}),~(q, p'))\mid p, p', q, f.~p'\in \mathcal{Q}~\mathcal{A} \land$|
          |$(p, (\texttt{None}, f), q)\in \Delta_T \mathcal{T} \land \exists S. (\mathcal{M}~\mathcal{T})~f~\text{None} = \text{Some } S\} ~\cup$|
        |$\{((p,p'),~\texttt{the }(F~((\mathcal{M}~\mathcal{T})~f)~(\sigma_1\cap\sigma_2)),~(q, q'))\mid p, p', q, \sigma_1, \sigma_2, q', f.~$|
          |$ (p, (\text{Some }\sigma_1, f), q)\in \Delta_T~\mathcal{T} \land (p', \sigma_2, q')\in\Delta~\mathcal{A}\land \sigma_1\cap \sigma_2 = \emptyset \land$|
            |$ \exists S.~F~((\mathcal{M}~\mathcal{T})~f)~(\sigma_1\cap\sigma_2) = \text{Some } S\}$|,
    |$\Delta_e' = \{((p,p'),~\text{the }(((\mathcal{M}~\mathcal{T})~f)\texttt{ None}),~(q, p'))\mid p, p', q, f.~p'\in \mathcal{Q}~\mathcal{A} \land$|
          |$(p, (None, f), q)\in \Delta_T~\mathcal{T} \land (\mathcal{M}~\mathcal{T})~f~\texttt{None} = \text{None}\} ~\cup$|
        |$\{((p,p'),~\texttt{the }(F~((\mathcal{M}~\mathcal{T})~f)~(\sigma_1\cap\sigma_2)),~(q, q'))\mid p, p', q, \sigma_1, \sigma_2, q', f.~$|
          |$ (p, (\text{Some }\sigma_1, f), q)\in \Delta_T~\mathcal{T} \land (p', \sigma_2, q')\in\Delta~\mathcal{A}\land \sigma_1\cap \sigma_2 = \emptyset \land$|
            |$ \exists x\in(\sigma_1\cap\sigma_2).~((\mathcal{M}~\mathcal{T})~f)~(\text{Some } x) = \text{None} \}$|,
    |$\mathcal{I}_e = \mathcal{I}_t~\mathcal{T} \times \mathcal{I}~\mathcal{A}$|
    |$\mathcal{F}_e = \mathcal{F}_t~\mathcal{T} \times \mathcal{F}~\mathcal{A}$| |$\rrparenthesis$|"
	\end{lstlisting}
\caption{The formalization of $\varepsilon-$NFA and NFA in Isabelle/HOL}
\label{fig-def-FTProd}
\end{figure}

Figure \ref{fig-def-FTProd} depicts the abstract level formalization for the product of an SFT and an NFA. The parameters $\mathcal{T}$ and $\mathcal{A}$ are intuitive. But we need to explain the role of \texttt{F}. The output function is of type $'a \Rightarrow 'b \text{set option}$, which applies to a single element of the type $'a$. $\texttt{F}$ extends this function to apply it to a set of elements. More precisely, let $f$ be an output function, the semantics of $\texttt{F}$ is defined as $\texttt{F}~f~A=\bigcup_{a\in A} (\text{if }f~a= \text{Some }S \texttt{ then } S \texttt{ else } \emptyset)$.
The transition relations $\Delta_e$ and $\Delta_e'$ are defined by splitting into two cases, whether the transitions in SFTs are $\varepsilon$-transitions or not. 

In order to prove this abstract definition of product operation's correctness, we firstly formalize the outputs of an NFT regarding the input of an NFA. Figure \ref{fig-def-output} has two definitions: (1) \texttt{outputE} extracts the output (second element) from a path. (2) \texttt{outputL} defines the set of all outputs of an NFT $\mathcal{T}$, regarding the input language $\mathcal{A}$.

\begin{figure}[ht]
	\begin{lstlisting}
fun outputE :: "|$('a \text{ option} \times 'b \text{ option}) \text{ list} \Rightarrow 'b \text{ list}$|" where
  "outputE [] = []" |$\mid$|
  "outputE ((_, Some a) # l) = a # (outputE l)" |$\mid$|
  "outputE ((_, None) # l) = (outputE l)"

definition outputL :: "|$('q, 'a, 'b, 'c)\text{  NFT} \Rightarrow $|
            |$ ('c \Rightarrow ('a, 'b)\text{  Tlabel}) \Rightarrow 
                               ('q, 'a) \text{ NFA\_rec} \Rightarrow 'b\text{ list set}$|" where
  "outputL |$\mathcal{T}$| M |$\mathcal{A}$| = {outputE |$\pi~\mid~\pi~q~q'$|. |$q\in \mathcal{I}_T~\mathcal{T} \land q' \in \mathcal{F}_T~\mathcal{T} \land$|
                |$ \text{LTTS\_reachable }(\Delta_T~\mathcal{T})~\text{M}~q~\pi~q'\land \text{inputE }\pi\in \mathcal{L}~\mathcal{A}$|}" 
	\end{lstlisting}
\caption{The formalization of $\varepsilon-$NFA and NFA in Isabelle/HOL}
\label{fig-def-output}
\end{figure}


\begin{figure}[ht]
	\begin{lstlisting}
lemma productT_correct:
  fixes |$\mathcal{T}$| |$\mathcal{A}$| F
  assumes F_ok1: "|$\forall~f~s.~(\forall e \in s. f (\text{ Some } e) = \text{None}) \mapsto \text{ F}~f~s = \text{None}"$|
      and F_ok2: "|$\forall~f~s.~\text{F }f~s = $|
            |$\text{Some }(\cup \{\text{the }(f (\text{ Some }e))\mid e. e \in s \land f~(\text{Some }e) \neq \text{ None}\})$|"
      and wfTA: "NFT_wf |$\mathcal{T}~\land \text{ NFA } \mathcal{A}$|"
    shows "|$\mathcal{L}_e$| (productT |$\mathcal{T}~\mathcal{A}$| F) = outputL |$\mathcal{T}~(\mathcal{M}~\mathcal{T})~\mathcal{A}$|"

	\end{lstlisting}
\caption{The formalization of $\varepsilon-$NFA and NFA in Isabelle/HOL}
\label{fig-def-product-correct}
\end{figure}

Figure \ref{fig-def-product-correct} shows the correctness of the product operation and Figure \ref{fig-def-output} contains the definitions of \texttt{outputE} and \texttt{outputL} that are used in Lemma \texttt{productT\_correct}.
The two assumptions define the constraints of the function \texttt{F}.
The conclusion in \textcolor{blue}{\texttt{show}} illustrates 
that the language equivalence between the production definition and mathematical semantics.

\section{Algorithm Level Refinement}
We have 

\end{document}
