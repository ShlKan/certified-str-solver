\section{Symbolic Finite Transducers}
\label{sec:sft}


We begin by presenting a mathematical definition of SFTs \cite{VeanesHLMB12Transducer}, abstracting from the specific implementation details of Isabelle/HOL.

Let $\mathcal{U}$ be a multi-sorted carrier set or background universe, which is equipped with functions and relations over the elements. We use $\tau$ as a sort and $\mathcal{U}^\tau$ denotes the sub-universe of elements of type $\tau$.
We have a special type $\mathbb{B}$ with $\mathcal{U}^\mathbb{B} = \{ \top, \bot\}$, which corresponds to the boolean type.

A lambda term is defined as $\lambda x.~t$ of type $\tau_1 \rightarrow \tau_2$.
When $\tau_2$ is $\mathbb{B}$, this lambda term is a predicate. Let $\phi$ be a predicate. We write $a\in \llbracket\phi \rrbracket$ if $\phi~a=\top$. For non-predicate lambda terms, we view them as functions that generate output elements of type $\tau_2$ given input terms of type $\tau_1$.
With these notations and the above definitions, we can define SFTs as follows.

\begin{definition}[Symbolic Finite Transducer]
\label{def-sft}
   A Symbolic Finite Transducer over $\tau_1\rightarrow \tau_2$ is a quadruple $\mathcal{T} = (\mathcal{Q}, \Delta, \mathcal{I}, \mathcal{F})$, where 
   \begin{itemize}
   \item $\mathcal{Q}$ is a finite set of states,
   \item $\mathcal{I}\subseteq \mathcal{Q}$ is the set of initial states,
   \item $\mathcal{F} \subseteq\mathcal{Q}$ is the set of accepting states,
   \item $\Delta$ is the set of transition relations. Each element in $\Delta$ is of the form $(q, \phi, f, q')$ or written as $q\xrightarrow{\phi, f} q'$, where $q$ and $q'$ are states in $\mathcal{Q}$.
   $\phi$ is a predicate of type $\tau_1\rightarrow \mathbb{B}$.
   $f$ is a lambda term of type $\tau_1\rightarrow \tau_2$. $f$ is called an \emph{output function}.
   \end{itemize}

For each transition $q\xrightarrow{\phi, f} q'$, if there exists an element $a\in \llbracket \phi \rrbracket$, where $a$ is called an input,  then the application $(f~a)$ is the output.
   
\end{definition}

SFTs accept an input word and generate an output word. This can be defined by \emph{runs} of SFTs.
An SFT run $\sigma$ is a sequence $(q_0, \phi_0, f_0, q_1),(q_1, \phi_1, f_1, q_2),\ldots, (q_{n-1}, \phi_{n-1}, f_{n-1}, q_n)$ such that $q_0\in \mathcal{I}$ and $(q_i,
\phi_i, f_i, q_{i+1}), 0 \leq i \leq n-1$ is a transition in $\Delta$.
$\sigma$ is an accepting run when $q_n$ is an accepting state.

For a word $w = a_0,\ldots, a_{n-1}$, it is accepted by $\sigma$ if and only if $a_i \in \llbracket\phi_i \rrbracket$ for $0 \leq i \leq n - 1$. When $w$ is accepted, run $\sigma$ generates an output sequence $w'= f_0~a_0, \ldots, f_{n-1}~a_{n-1}$. We define:
\begin{itemize}
\item  $(a_0,(f_0~a_0)), \ldots, (a_{n-1},(f_{n-1}~a_{n-1}))$ a \emph{trace},
\item $a_0,\ldots,a_{n-1}$ the \emph{input} of the trace and $(f_0~a_0), \ldots, $ $(f_{n-1}~a_{n-1})$ the \emph{output} of the trace.
\end{itemize}

If $a_0,\ldots,a_{n-1}$ is accepted by an accepting run in $\mathcal{T}$, we say that the trace is an accepting trace of $\mathcal{T}$.
For a trace $\pi$, we denote its input as $\mathit{in}(\pi)$ and its output as $\mathit{out}(\pi)$.
%
Given an SFT $\mathcal{T}$ and a word $w$, we define the \emph{product} operation of $\mathcal{T}$ and $w$ (denoted as $\mathcal{T}\times\{w\}$) as the set of outputs generated by $\mathcal{T}$ with input $w$. More precisely,
\[
\begin{split}
\mathcal{T}\times\{w\} = \{w'\mid \exists \pi.~\pi \text{ is an accepting trace of } \mathcal{T} \land \\ \mathit{in}(\pi) = w \land \mathit{out}(\pi) = w'\}.
\end{split}
\]

To make the operation \emph{product} more general, we extend the operation to an SFT and a set of input words represented by a regular language, which can be denoted by an SFA $\mathcal{A}$. More precisely,
\[
\begin{split}
\mathcal{T}\times \mathcal{A} = \{w'\mid \exists w.~w\in \mathcal{L}(\mathcal{A})\land w' \in \mathcal{T}\times\{w\}\}, \\\text{ where }\mathcal{L}(\mathcal{A})\text{ denotes the language of }\mathcal{A}.
\end{split}
\]

\begin{figure}[hbt!]
  \centering
  \begin{tikzpicture}[shorten >=1pt, node distance=2.5cm and 2cm, on grid, auto]
    % Make q0 and q1 horizontally wide apart
    \node[state, initial] (q_0)   {$q_0$}; 
    \node[state] (q_1) [right=4cm of q_0] {$q_1$}; 
    \node[state, accepting] (q_2) [below=2.2cm of q_1] {$q_2$}; 
 
    \path[->] 
    (q_0) edge node {[$'\texttt{a}'-'\texttt{z}'$],$f_1$} (q_1)
    (q_1) edge node[right] {[$'\texttt{A}'-'\texttt{Z}'$],$f_2$} (q_2)
    (q_1) edge[loop above] node {[$'\texttt{a}'-'\texttt{z}'$],$f_1$} (q_1)
    (q_2) edge[loop below] node {[$'\texttt{A}'-'\texttt{Z}'$],$f_2$} (q_2);
  \end{tikzpicture}
    \caption{An example of SFT}
    \label{fig-example-ft}
\end{figure}

    Figure \ref{fig-example-ft} illustrates an SFT that accepts words matching the regular expression $/['\texttt{a}'-'\texttt{z}']+['\texttt{A}'-'\texttt{Z}']+/$. The transition labels utilize intervals of the form $[i\text{-}j]$, which are interpreted as predicates $\lambda x.~i \leq x \leq j$. The output functions $f_1$ and $f_2$ perform case transformations: $f_1 = \lambda x.~\texttt{toUpper}(x)$ converts lowercase letters to uppercase, while $f_2 = \lambda x.~\texttt{toLower}(x)$ performs the inverse operation. For example, given the input string \texttt{"bigSMALL"}, this SFT produces the output \texttt{"BIGsmall"}.


%The transition labels can be more complex. For instance, it can be a predicate over integers as: $\lambda x.~ x >0 \land x \text{ mod } 2 = 0$. This symbolic label corresponds to the set of even natural numbers.